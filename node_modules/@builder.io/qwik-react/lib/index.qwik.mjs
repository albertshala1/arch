import { useSignal, useOn, useOnDocument, inlinedQrl, useLexicalScope, _jsxC, SSRStream, SSRRaw, _jsxQ, Slot, componentQrl, _jsxBranch, useStylesScopedQrl, useTaskQrl, noSerialize, RenderOnce, SkipRender, _IMMUTABLE, implicit$FirstArg } from "@builder.io/qwik";
import { isServer, isBrowser } from "@builder.io/qwik/build";
import { createRoot, hydrateRoot } from "react-dom/client";
import { flushSync } from "react-dom";
import { Fragment } from "@builder.io/qwik/jsx-runtime";
import { createContext, Component, createRef, createElement } from "react";
import { renderToString } from "react-dom/server";
const SlotCtx = createContext({
  scopeId: ""
});
function main(slotEl, scopeId, RootCmp, props) {
  const newProps = getReactProps(props);
  return mainExactProps(slotEl, scopeId, RootCmp, newProps);
}
function mainExactProps(slotEl, scopeId, RootCmp, props) {
  return createElement(SlotCtx.Provider, {
    value: {
      el: slotEl,
      scopeId,
      attachedEl: void 0
    },
    children: createElement(RootCmp, {
      ...props,
      children: createElement(SlotElement, null)
    })
  });
}
class SlotElement extends Component {
  constructor() {
    super(...arguments);
    this.slotC = createRef();
  }
  shouldComponentUpdate() {
    return false;
  }
  componentDidMount() {
    const slotC = this.slotC.current;
    if (slotC) {
      const { attachedEl, el } = this.context;
      if (el) {
        if (!attachedEl)
          slotC.appendChild(el);
        else if (attachedEl !== slotC)
          throw new Error("already attached");
      }
    }
  }
  render() {
    return createElement("q-slotc", {
      class: this.context.scopeId,
      suppressHydrationWarning: true,
      dangerouslySetInnerHTML: {
        __html: "<!--SLOT-->"
      },
      ref: this.slotC
    });
  }
}
SlotElement.contextType = SlotCtx;
const getReactProps = (props) => {
  const obj = {};
  Object.keys(props).forEach((key) => {
    if (!key.startsWith("client:") && !key.startsWith("host:")) {
      const normalizedKey = key.endsWith("$") ? key.slice(0, -1) : key;
      obj[normalizedKey] = props[key];
    }
  });
  return obj;
};
const getHostProps = (props) => {
  const obj = {};
  Object.keys(props).forEach((key) => {
    if (key.startsWith("host:"))
      obj[key.slice(HOST_PREFIX.length)] = props[key];
  });
  return obj;
};
const useWakeupSignal = (props, opts = {}) => {
  const signal = useSignal(false);
  const activate = /* @__PURE__ */ inlinedQrl(() => {
    const [signal2] = useLexicalScope();
    return signal2.value = true;
  }, "useWakeupSignal_activate_6LYztwGzxAA", [
    signal
  ]);
  const clientOnly = !!(props["client:only"] || opts?.clientOnly);
  if (isServer) {
    if (props["client:visible"] || opts?.eagerness === "visible")
      useOn("qvisible", activate);
    if (props["client:idle"] || opts?.eagerness === "idle")
      useOnDocument("qidle", activate);
    if (props["client:load"] || clientOnly || opts?.eagerness === "load")
      useOnDocument("qinit", activate);
    if (props["client:hover"] || opts?.eagerness === "hover")
      useOn("mouseover", activate);
    if (props["client:event"])
      useOn(props["client:event"], activate);
    if (opts?.event)
      useOn(opts?.event, activate);
  }
  return [
    signal,
    clientOnly,
    activate
  ];
};
const HOST_PREFIX = "host:";
async function renderFromServer(Host, reactCmp$, scopeId, props, ref, slotRef, hydrationProps) {
  if (isServer) {
    const Cmp = await reactCmp$.resolve();
    const newProps = getReactProps(props);
    Object.assign(hydrationProps, newProps);
    const html = renderToString(mainExactProps(void 0, scopeId, Cmp, newProps));
    const index = html.indexOf("<!--SLOT-->");
    if (index > 0) {
      const part1 = html.slice(0, index);
      const part2 = html.slice(index + 11);
      return /* @__PURE__ */ _jsxC(Host, {
        ref,
        ...getHostProps(props),
        children: /* @__PURE__ */ _jsxC(SSRStream, {
          children: async function* () {
            yield /* @__PURE__ */ _jsxC(SSRRaw, {
              data: part1
            }, 3, "0a_3");
            yield /* @__PURE__ */ _jsxQ("q-slot", {
              ref: slotRef
            }, null, /* @__PURE__ */ _jsxC(Slot, null, 3, "0a_4"), 1, null);
            yield /* @__PURE__ */ _jsxC(SSRRaw, {
              data: part2
            }, 3, "0a_5");
          }
        }, 1, "0a_6")
      }, 1, "0a_7");
    }
    return /* @__PURE__ */ _jsxC(Fragment, {
      children: [
        /* @__PURE__ */ _jsxC(Host, {
          ref,
          children: /* @__PURE__ */ _jsxC(SSRRaw, {
            data: html
          }, 3, "0a_8")
        }, 1, "0a_9"),
        /* @__PURE__ */ _jsxQ("q-slot", {
          ref: slotRef
        }, null, /* @__PURE__ */ _jsxC(Slot, null, 3, "0a_10"), 1, null)
      ]
    }, 1, "0a_11");
  }
}
function qwikifyQrl(reactCmp$, opts) {
  return /* @__PURE__ */ componentQrl(/* @__PURE__ */ inlinedQrl((props) => {
    const [opts2, reactCmp$2] = useLexicalScope();
    _jsxBranch();
    const stylesscoped$ = useStylesScopedQrl(/* @__PURE__ */ inlinedQrl(`q-slot{display:none} q-slotc,q-slotc>q-slot{display:contents}`, "qwikifyQrl_component_stylesscoped_useStylesScoped_hkT84xKSMLE"));
    const hostRef = useSignal();
    const slotRef = useSignal();
    const internalState = useSignal();
    const [signal, isClientOnly] = useWakeupSignal(props, opts2);
    const hydrationKeys = {};
    const TagName = opts2?.tagName ?? "qwik-react";
    useTaskQrl(/* @__PURE__ */ inlinedQrl(async ({ track }) => {
      const [hostRef2, hydrationKeys2, internalState2, isClientOnly2, props2, reactCmp$3, signal2, slotRef2, stylesscoped$2] = useLexicalScope();
      const trackedProps = track(() => ({
        ...props2
      }));
      track(signal2);
      if (!isBrowser)
        return;
      if (internalState2.value) {
        if (internalState2.value.root)
          internalState2.value.root.render(main(slotRef2.value, stylesscoped$2.scopeId, internalState2.value.cmp, trackedProps));
      } else {
        let root = void 0;
        const Cmp = await reactCmp$3.resolve();
        const hostElement = hostRef2.value;
        if (hostElement) {
          if (isClientOnly2)
            root = createRoot(hostElement);
          else
            root = flushSync(() => {
              return hydrateRoot(hostElement, mainExactProps(slotRef2.value, stylesscoped$2.scopeId, Cmp, hydrationKeys2));
            });
          if (isClientOnly2 || signal2.value === false)
            root.render(main(slotRef2.value, stylesscoped$2.scopeId, Cmp, trackedProps));
        }
        internalState2.value = noSerialize({
          cmp: Cmp,
          root
        });
      }
    }, "qwikifyQrl_component_useTask_EWIT9ENzUX0", [
      hostRef,
      hydrationKeys,
      internalState,
      isClientOnly,
      props,
      reactCmp$2,
      signal,
      slotRef,
      stylesscoped$
    ]));
    if (isServer && !isClientOnly) {
      const jsx = renderFromServer(TagName, reactCmp$2, stylesscoped$.scopeId, props, hostRef, slotRef, hydrationKeys);
      return /* @__PURE__ */ _jsxC(RenderOnce, {
        children: jsx
      }, 1, 2);
    }
    return /* @__PURE__ */ _jsxC(RenderOnce, {
      children: [
        /* @__PURE__ */ _jsxC(TagName, {
          ...getHostProps(props),
          ref: (el) => {
            if (isBrowser)
              queueMicrotask(() => {
                const internalData = internalState.value;
                if (internalData && !internalData.root) {
                  const root = internalData.root = createRoot(el);
                  root.render(main(slotRef.value, stylesscoped$.scopeId, internalData.cmp, props));
                }
              });
            else
              hostRef.value = el;
          },
          children: SkipRender,
          [_IMMUTABLE]: {
            ref: _IMMUTABLE
          }
        }, 1, "6S_0"),
        /* @__PURE__ */ _jsxQ("q-slot", {
          ref: slotRef
        }, null, /* @__PURE__ */ _jsxC(Slot, null, 3, "6S_1"), 1, null)
      ]
    }, 1, "6S_2");
  }, "qwikifyQrl_component_zH94hIe0Ick", [
    opts,
    reactCmp$
  ]));
}
const qwikify$ = /* @__PURE__ */ implicit$FirstArg(qwikifyQrl);
export {
  qwikify$,
  qwikifyQrl
};
