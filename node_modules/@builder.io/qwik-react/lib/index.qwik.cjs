"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const qwik = require("@builder.io/qwik");
const build = require("@builder.io/qwik/build");
const client = require("react-dom/client");
const reactDom = require("react-dom");
const jsxRuntime = require("@builder.io/qwik/jsx-runtime");
const react = require("react");
const server = require("react-dom/server");
const SlotCtx = react.createContext({
  scopeId: ""
});
function main(slotEl, scopeId, RootCmp, props) {
  const newProps = getReactProps(props);
  return mainExactProps(slotEl, scopeId, RootCmp, newProps);
}
function mainExactProps(slotEl, scopeId, RootCmp, props) {
  return react.createElement(SlotCtx.Provider, {
    value: {
      el: slotEl,
      scopeId,
      attachedEl: void 0
    },
    children: react.createElement(RootCmp, {
      ...props,
      children: react.createElement(SlotElement, null)
    })
  });
}
class SlotElement extends react.Component {
  constructor() {
    super(...arguments);
    this.slotC = react.createRef();
  }
  shouldComponentUpdate() {
    return false;
  }
  componentDidMount() {
    const slotC = this.slotC.current;
    if (slotC) {
      const { attachedEl, el } = this.context;
      if (el) {
        if (!attachedEl)
          slotC.appendChild(el);
        else if (attachedEl !== slotC)
          throw new Error("already attached");
      }
    }
  }
  render() {
    return react.createElement("q-slotc", {
      class: this.context.scopeId,
      suppressHydrationWarning: true,
      dangerouslySetInnerHTML: {
        __html: "<!--SLOT-->"
      },
      ref: this.slotC
    });
  }
}
SlotElement.contextType = SlotCtx;
const getReactProps = (props) => {
  const obj = {};
  Object.keys(props).forEach((key) => {
    if (!key.startsWith("client:") && !key.startsWith("host:")) {
      const normalizedKey = key.endsWith("$") ? key.slice(0, -1) : key;
      obj[normalizedKey] = props[key];
    }
  });
  return obj;
};
const getHostProps = (props) => {
  const obj = {};
  Object.keys(props).forEach((key) => {
    if (key.startsWith("host:"))
      obj[key.slice(HOST_PREFIX.length)] = props[key];
  });
  return obj;
};
const useWakeupSignal = (props, opts = {}) => {
  const signal = qwik.useSignal(false);
  const activate = /* @__PURE__ */ qwik.inlinedQrl(() => {
    const [signal2] = qwik.useLexicalScope();
    return signal2.value = true;
  }, "useWakeupSignal_activate_6LYztwGzxAA", [
    signal
  ]);
  const clientOnly = !!(props["client:only"] || opts?.clientOnly);
  if (build.isServer) {
    if (props["client:visible"] || opts?.eagerness === "visible")
      qwik.useOn("qvisible", activate);
    if (props["client:idle"] || opts?.eagerness === "idle")
      qwik.useOnDocument("qidle", activate);
    if (props["client:load"] || clientOnly || opts?.eagerness === "load")
      qwik.useOnDocument("qinit", activate);
    if (props["client:hover"] || opts?.eagerness === "hover")
      qwik.useOn("mouseover", activate);
    if (props["client:event"])
      qwik.useOn(props["client:event"], activate);
    if (opts?.event)
      qwik.useOn(opts?.event, activate);
  }
  return [
    signal,
    clientOnly,
    activate
  ];
};
const HOST_PREFIX = "host:";
async function renderFromServer(Host, reactCmp$, scopeId, props, ref, slotRef, hydrationProps) {
  if (build.isServer) {
    const Cmp = await reactCmp$.resolve();
    const newProps = getReactProps(props);
    Object.assign(hydrationProps, newProps);
    const html = server.renderToString(mainExactProps(void 0, scopeId, Cmp, newProps));
    const index = html.indexOf("<!--SLOT-->");
    if (index > 0) {
      const part1 = html.slice(0, index);
      const part2 = html.slice(index + 11);
      return /* @__PURE__ */ qwik._jsxC(Host, {
        ref,
        ...getHostProps(props),
        children: /* @__PURE__ */ qwik._jsxC(qwik.SSRStream, {
          children: async function* () {
            yield /* @__PURE__ */ qwik._jsxC(qwik.SSRRaw, {
              data: part1
            }, 3, "0a_3");
            yield /* @__PURE__ */ qwik._jsxQ("q-slot", {
              ref: slotRef
            }, null, /* @__PURE__ */ qwik._jsxC(qwik.Slot, null, 3, "0a_4"), 1, null);
            yield /* @__PURE__ */ qwik._jsxC(qwik.SSRRaw, {
              data: part2
            }, 3, "0a_5");
          }
        }, 1, "0a_6")
      }, 1, "0a_7");
    }
    return /* @__PURE__ */ qwik._jsxC(jsxRuntime.Fragment, {
      children: [
        /* @__PURE__ */ qwik._jsxC(Host, {
          ref,
          children: /* @__PURE__ */ qwik._jsxC(qwik.SSRRaw, {
            data: html
          }, 3, "0a_8")
        }, 1, "0a_9"),
        /* @__PURE__ */ qwik._jsxQ("q-slot", {
          ref: slotRef
        }, null, /* @__PURE__ */ qwik._jsxC(qwik.Slot, null, 3, "0a_10"), 1, null)
      ]
    }, 1, "0a_11");
  }
}
function qwikifyQrl(reactCmp$, opts) {
  return /* @__PURE__ */ qwik.componentQrl(/* @__PURE__ */ qwik.inlinedQrl((props) => {
    const [opts2, reactCmp$2] = qwik.useLexicalScope();
    qwik._jsxBranch();
    const stylesscoped$ = qwik.useStylesScopedQrl(/* @__PURE__ */ qwik.inlinedQrl(`q-slot{display:none} q-slotc,q-slotc>q-slot{display:contents}`, "qwikifyQrl_component_stylesscoped_useStylesScoped_hkT84xKSMLE"));
    const hostRef = qwik.useSignal();
    const slotRef = qwik.useSignal();
    const internalState = qwik.useSignal();
    const [signal, isClientOnly] = useWakeupSignal(props, opts2);
    const hydrationKeys = {};
    const TagName = opts2?.tagName ?? "qwik-react";
    qwik.useTaskQrl(/* @__PURE__ */ qwik.inlinedQrl(async ({ track }) => {
      const [hostRef2, hydrationKeys2, internalState2, isClientOnly2, props2, reactCmp$3, signal2, slotRef2, stylesscoped$2] = qwik.useLexicalScope();
      const trackedProps = track(() => ({
        ...props2
      }));
      track(signal2);
      if (!build.isBrowser)
        return;
      if (internalState2.value) {
        if (internalState2.value.root)
          internalState2.value.root.render(main(slotRef2.value, stylesscoped$2.scopeId, internalState2.value.cmp, trackedProps));
      } else {
        let root = void 0;
        const Cmp = await reactCmp$3.resolve();
        const hostElement = hostRef2.value;
        if (hostElement) {
          if (isClientOnly2)
            root = client.createRoot(hostElement);
          else
            root = reactDom.flushSync(() => {
              return client.hydrateRoot(hostElement, mainExactProps(slotRef2.value, stylesscoped$2.scopeId, Cmp, hydrationKeys2));
            });
          if (isClientOnly2 || signal2.value === false)
            root.render(main(slotRef2.value, stylesscoped$2.scopeId, Cmp, trackedProps));
        }
        internalState2.value = qwik.noSerialize({
          cmp: Cmp,
          root
        });
      }
    }, "qwikifyQrl_component_useTask_EWIT9ENzUX0", [
      hostRef,
      hydrationKeys,
      internalState,
      isClientOnly,
      props,
      reactCmp$2,
      signal,
      slotRef,
      stylesscoped$
    ]));
    if (build.isServer && !isClientOnly) {
      const jsx = renderFromServer(TagName, reactCmp$2, stylesscoped$.scopeId, props, hostRef, slotRef, hydrationKeys);
      return /* @__PURE__ */ qwik._jsxC(qwik.RenderOnce, {
        children: jsx
      }, 1, 2);
    }
    return /* @__PURE__ */ qwik._jsxC(qwik.RenderOnce, {
      children: [
        /* @__PURE__ */ qwik._jsxC(TagName, {
          ...getHostProps(props),
          ref: (el) => {
            if (build.isBrowser)
              queueMicrotask(() => {
                const internalData = internalState.value;
                if (internalData && !internalData.root) {
                  const root = internalData.root = client.createRoot(el);
                  root.render(main(slotRef.value, stylesscoped$.scopeId, internalData.cmp, props));
                }
              });
            else
              hostRef.value = el;
          },
          children: qwik.SkipRender,
          [qwik._IMMUTABLE]: {
            ref: qwik._IMMUTABLE
          }
        }, 1, "6S_0"),
        /* @__PURE__ */ qwik._jsxQ("q-slot", {
          ref: slotRef
        }, null, /* @__PURE__ */ qwik._jsxC(qwik.Slot, null, 3, "6S_1"), 1, null)
      ]
    }, 1, "6S_2");
  }, "qwikifyQrl_component_zH94hIe0Ick", [
    opts,
    reactCmp$
  ]));
}
const qwikify$ = /* @__PURE__ */ qwik.implicit$FirstArg(qwikifyQrl);
exports.qwikify$ = qwikify$;
exports.qwikifyQrl = qwikifyQrl;
